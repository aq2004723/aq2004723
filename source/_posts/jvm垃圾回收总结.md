# jvm垃圾回收总结

## 4种垃圾回收算法
1. 标记-清除
1. 复制算法
1. 标记-整理
1. 分代收集

#### 标记-清除
分为两个步骤
标记出所有要回收对象：
一般使用根节点，所有通过节点不可达的对象将被标记
回收所有已标记对象
回收被标记对象的内存

缺点：效率低，产生碎片

#### 复制算法
将内存分为两个部分，当一个部分满了后，将所有存活对象连续的复制到另一部分，并且清楚老的部分的全部对象内存

优点：解决的了标记-清楚算法产生的碎片问题
缺点: 只使用了一个一半内存，资源浪费严重，存活对象较多会复制会产生较大开销

>为了解决内存浪费的问题
将内存区域化为一个Eden区和两个survivor区，每次使用Eden区和一个survivor区
过程是一个survivor区 将存活对象复制到另一个survivor区


#### 标记-整理
标记-整理方法大致和标记清楚算法一致，标记后不清楚，将对象复制到一端，清楚尾端

#### 分代收集
现代虚拟机均使用这种方案
一般将内存分为两个部分 新生代和老年代

新生代有大量新对象产生，又会有大量对象被回收，采用复制算法

老年代对象相对长期存活 使用标记-清除或标记-整理算法


## 几种垃圾收集器实现对比
![几种垃圾收集器实现](http://image.hloli.me/18-03-27/1522123699340.jpg)

垃圾回收器 | 实现算法 | 作用空间 | 实现描述 | 适用场景 | 优点 | 缺点
---- | --- | ---- | --- | --- | --- | --- |
 Serial | 复制算法 | 新生代 | 暂停所有用户线程，执行gc线程，默认运行在client模式下 | 简单程序、小型客户端程序 | 简单、高效，针对单cpu构架有很好的表现 | stop the world，表现为程序卡顿
 ParNew 收集器|  复制算法 | 新生代 | Serial收集器的多线程版本 | server模式下首选的模式| 能与CMS收集器一起作用，在多核心情况下相比Serial有较高效率 |
 paralled scavenge收集器| 复制算法 | 新生代  |  更关注吞吐量，即运行中占总时间（运行时间+gc时间）的百分比，可以不指定Eden区和suvivor区比例，系统根据运行情况自动调节| 更关注吞吐量的情况，对CPU资源敏感 |
 Serial Old 收集器| 标记-整理 | 老年代 | Serial算法的老年代版本 | client模式下默认的老年带收集器，在Server模式下常作为CMS失效的情况下的后备收集算法 |
 paralled old 收集器| 多线程的 标记-整理算法 | 老年代 | 配合 paralled scavenge收集器 完成对cpu资源敏感的收集 | 与  paralled scavenge收集器 配合使用
 CMS收集器 | 标记清除 | 老年代 | 目标是停顿时间最短，实现见下面的讨论 |  互联网BS构架中常用的服务端收集器 | 并发收集、低停顿 | CPU敏感，默认线程数是（CPU数量 + 3 ) / 4,少于4个cpu的情况下有时会显著降低反应速度， 其次，因为浮动垃圾的存在有时会发生 收集失败，从而触发full gc 导致时间变长。使用标记-清除算法，有碎片问题产生，碎片过多也会触发full gc
 g1 收集器| 标记-整理 加 复制 | 全堆空间 | 详细见下面 | 用于在BS构架中替代CMS

#### CMS 垃圾收集器简述
分为四个阶段
* 初始标记   标记根对象
* 并发标记   标记可达对象
* 重新标记   标记产生变动的对象
* 并发清除   编发清除

过程如下图
![img](http://image.hloli.me/18-03-27/1522139736358.jpg)
前三个阶段会触发停顿


#### G1 垃圾收集器简述
暂无



## 垃圾收集器参数总结
 ![img](http://image.hloli.me/18-03-27/1522139358525.jpg)



## 选用问题
使用spring进行开发时一般根据cpu核心数来进行选择（如无特殊需求）
大于等于4核心 使用CMS + ParNew 收集器
小于4核心    使用  Serial Old  + ParNew 收集器

g1收集器目前还没有使用过，不做评价，但是越来越多的项目使用G1收集器  值得考虑

title: java类加载详解
tags: "java" "jvm"
---

# java类加载详解
# 类加载过程

![img](http://image.hloli.me/18-04-28/1524897048754.jpg)
分为7个阶段

## 加载：
1. 通过一个类的全限定名来获取定义此类的二进制字节流
2. 将这个字节流所代表的静态存储结构转好为方法区的运行时数据结构，
3. 内存中生成一个代表这个类的java class对象，作为方法去这个类的各种数据的访问入口

加载的过程，可以从多个地方类文件，如压缩文件jar、zip、war等可以动态生成 ，网络获取 etc

经过加载 外部二进制流存入方法区中。内存中实例化一个class类的对象


> 方法区和永久带  
>   
> 方法区（method area）只是JVM规范中定义的一个概念，用于存储类信息、常量池、静态变量、JIT编译后的代码等数据，具体放在哪里，不同的实现可以放在不同的地方。而永久代是Hotspot虚拟机特有的概念，是方法区的一种实现，别的JVM都没有这个东西。  
>   
> 在Java 6中，方法区中包含的数据，除了JIT编译生成的代码存放在native memory的CodeCache区域，其他都存放在永久代；  
> 在Java 7中，Symbol的存储从PermGen移动到了native memory，并且把静态变量从instanceKlass末尾（位于PermGen内）移动到了java.lang.Class对象的末尾（位于普通Java heap内）；  
> 在Java 8中，永久代被彻底移除，取而代之的是另一块与堆不相连的本地内存——元空间（Metaspace）,‑XX:MaxPermSize 参数失去了意义，取而代之的是-XX:MaxMetaspaceSize。  


## 验证阶段：
对二进制流进行验证（与加载交叉进行，上面的顺序只表示开始顺序，并不是一个阶段完成后才会开始下一个阶段）
验证大致分为4个阶段：
1. 文件格式验证
2. 元数据验证
3. 字节码验证
4. 符合引用验证

### 文件格式验证
验证二进制流文件，通过这个阶段的验证才会被放入方法区，后面三个阶段的验证是基于方法区的结构

字节码验证:
最复杂一个阶段，确定程序语义是否合法，类型转换是否有效，数据类型赋值检查等

符合引用验证：
引用的类是否能找到，是否能访问 （Public或其他符合访问原则）等


## 准备阶段
准备阶段是正式为类变量分配内存并设置类变量   初始值  的阶段，这些变量的内存豆子方法区中分配
但是如果变量是final 的（常量）那么此阶段就会赋值  此阶段可跳过


## 解析阶段
将常量池中的符号引用变为直接引用
这里比较复杂。之后详细补充下

## 初始化
最后一个阶段，收集所有**类变量**的赋值语句和静态语句块，形成一个<cinit>方法并执行（static 块中可以给后面的变量赋值，但是不能引用）子类初始化前会先初始化父类

注意是类变量 static 修饰且赋值的


# 类加载器与双亲委托
![img](http://image.hloli.me/18-04-28/1524898322109.jpg)
3个类加载器

启动类加载器（Bootstrap ClassLoader）：前面已经介绍过，这个类将器负责将存放在<JAVA_HOME>\lib目录中的，或者被-Xbootclasspath参数所指定的路径中的，并且是虚拟机识别的（仅按照文件名识别，如rt.jar，名字不符合的类库即使放在lib目录中也不会被加载）类库加载到虚拟机内存中。启动类加载器无法被Java程序直接引用，用户在编写自定义类加载器时，如果需要把加载请求委派给引导类加载器，那直接使用null代替即可，如代码清单7-9所示为java.lang.ClassLoader.getClassLoader()方法的代码片段。

扩展类加载器（Extension ClassLoader）：这个加载器由sun.misc.Launcher$ExtClassLoader实现，它负责加载<JAVA_HOME>\lib\ext目录中的，或者被java.ext.dirs系统变量所指定的路径中的所有类库，开发者可以直接使用扩展类加载器。

应用程序类加载器（Application ClassLoader）：这个类加载器由sun.misc.Launcher$App-ClassLoader实现。由于这个类加载器是ClassLoader中的getSystemClassLoader()方法的返回值，所以一般也称它为系统类加载器。它负责加载用户类路径（ClassPath）上所指定的类库，开发者可以直接使用这个类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。
我们的应用程序都是由这3种类加载器互相配合进行加载的，如果有必要，还可以加入自己定义的类加载器。这些类加载器之间的关系一般如图7-2所示。
￼
类加载器之间的这种层次关系，称为类加载器的双亲委派模型（Parents Delegation Model）。双亲委派模型要求除了顶层的启动类加载器外，其余的类加载器都应当有自己的父类加载器。这里类加载器之间的父子关系一般不会以继承（Inheritance）的关系来实现，而是都使用组合（Composition）关系来复用父加载器的代码。
类加载器的双亲委派模型在JDK 1.2期间被引入并被广泛应用于之后几乎所有的Java程序中，但它并不是一个强制性的约束模型，而是Java设计者推荐给开发者的一种类加载器实现方式。
双亲委派模型的工作过程是：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器


工作过程：类加载器收到请求先委派父加载器加载 加载失败才会用子类加载器加载
为了不破坏双亲委托  写类加载器时重载 findClass 方法


如果不想利用双亲委托这个特点也可以，重写loadClass方法即可
一些java应用服务器和OSGi都会打破双亲委托
